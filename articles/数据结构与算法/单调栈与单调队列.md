# 单调栈

核心思想---"如果一个选手比你小还比你强，你就可以退役了。"

单调递增\递减，栈内元素有序，对于数组中的某一元素，查找
其左边或右边第一个满足大小关系的元素。

> eg: 输入n个整数，给出每个元素左边第一个大于它的数，若无满足条件则输出-1

利用先进后出的特点，越靠近栈底的元素越远，越靠近栈顶越近；
当前扫描到的元素必定入栈，因为其可能成为后续将扫描元素的最优解；
当前元素入栈前，将数值不优于该元素的栈顶元素依次出栈，维护其单调性。

扫描一遍即可，扫描方向由题意确定，时间复杂度**O(n)**


```c++
// a数组读取数据，st模拟单调栈，top为栈顶指针(初值为0)
int n, a[Max], st[Max], top;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        while (top && a[i] >= st[top]) top--;
        if (top)
            cout << st[top] << " ";
        else
            cout << -1 << " ";

        st[++top] = a[i];
    }
}
```

# 单调队列

解决滑动窗口区间最值问题。

> eg: 给出n个整数，求以i结尾、区间不超过m的区间最值。

不同于单调栈，滑动窗口限制了区间范围，如果采用单调栈，
可能导致栈底元素超出区间，因此使用双端队列，维护单调性
的同时，维护队头在区间内。

队头相关处理与单调栈一致，遍历到的当前元素必定入队，
并将不优于该元素的队尾出队；每一次移动需要判断队头
是否超出范围，若是，则队头出队；由于需要判断索引是
否越界，队列存储对应的索引。

扫描一遍即可，时间复杂度**O(n)**

```c++
// n个整数，区间为m，l为队头指针，r为队尾指针
int n, m, a[N], q[N], l, r;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        // 队头越界，出队
        if (i - q[l] + 1 > m) l++;
        while (l < r && a[i] >= a[q[r-1]]) r--;
        q[r++] = i;
        // 队头即满足区间的最值
        if (i >= m) cout << a[q[l]] << " ";
    }
}
```
