# 基础树状数组

树状数组，又名二进制索引数组(Binary Indexed Tree)。

从二进制的角度分析节点编号，lowbit获取二进制最低位是该算法灵魂所在。

性质:

- 每个节点代表其子树权值之和(lowbit在第几位表示几段区间和)(不重要)

- f[k]至少包含a[k]

- 正数的负数为取反加1，两数&运算即可得到最低位

- k + lowbit(k)，跳到父节点(单点修改，从叶子一直往上走即可维护区间和)

- k - lowbit(k)，跳到左兄弟节点(k及其所有左兄弟之和即 [1 ~ k] 区间和)

- [x ~ y] 区间和可以表示为 [1 ~ y] 减去 [1 ~ x-1] 


通过二进制进行节点跳转，跳转次数不会超过二进制的位数。
相当于循环左移/右移，因此单次查询、修改操作的时间复杂度为**O(logn)**

```c++
                         _______________________________f[8]
                        |               |       |       1000
                        |               |       |       |
         _______________f[4]            |       |       |
        |       |       0100            |       |       |
        |       |       |               |       |       |
 _______f[2]    |       |        _______f[6]    |       |
|       0010    |       |       |       0110    |       |
|       |       |       |       |       |       |       |
f[1]    |       f[3]    |       f[5]    |       f[7]    |
0001    |       0011    |       0101    |       0111    |
|       |       |       |       |       |       |       |
a[1]    a[2]    a[3]    a[4]    a[5]    a[6]    a[7]    a[8]
0001    0010    0011    0100    0101    0110    0111    1000
```

```c++
// 数组a读入数据，数组f维护树状数组
int n, a[Max], f[Max];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i], add(i, a[i]);
    int x, y;
    cin >> x >> y; // 求区间和[x ~ y]
    cout << ask(y) - ask(x-1) << endl;
}
```

```c++
int lowbit(int x) {
    return x & (-x);
}

void add(int idx, int key) {
    while (idx <= n) {
        f[idx] += key; 
        idx += lowbit(idx); // 往上走更新维护父节点的值
    }
}

// 返回 1 ~ idx 区间和
int ask(int idx) {
    int res = 0;
    while (idx) {
        res += f[idx];
        idx -= lowbit(idx);
    }
    return res;
}
```
